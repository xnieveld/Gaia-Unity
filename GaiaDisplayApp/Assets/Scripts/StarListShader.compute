// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSClear

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
uint textureHeight;
uint textureWidth;
uint xChunks;
uint yChunks;
uint starCount;
uint starsPerChunkX;
uint starsPerChunkY;
float magIncrease;
float3 playerPos;
matrix rotationMatrix;
float playerAngle1;
float playerAngle2;
float horizontalAngleLeftBound;
float horizontalAngleRightBound;
float verticalAngleLeftBound;
float verticalAngleRightBound;
float fovh;
float fovv;
float twistyAngle;

struct Star {
	float x; 
    float y;
    float z;
    float r; //red
    float g; //green
    float b; //blue
    float m;
};


StructuredBuffer<Star> starList;
RWTexture2D<float4> Result;

float3 CartesianToPolar(float3 coord, float3 origin) {
	float3 correctedCoord = coord - origin;
	float3 returnCoord = float3(0, 0, 0);
	returnCoord.z = length(correctedCoord);

	returnCoord.x = atan(correctedCoord.z / correctedCoord.x);
	
	if (correctedCoord.x >= 0) {
		returnCoord.x += 3.14159265;
	}
	if (isnan(returnCoord.x))
	{
		if (correctedCoord.x >= 0)
		{
			returnCoord.x = 0;
		}
		else
		{
			returnCoord.x = 3.14159265;
		}
	}
	returnCoord.y = acos(correctedCoord.y / returnCoord.z);

	return returnCoord;
}

float2 WrapAngle(float2 angle)
{
	float maxVal = 3.14159265;

	if (angle.y > maxVal) {
		angle.y -= maxVal;
	}
	if (angle.y < 0) {
		angle.y += maxVal;
	}
	maxVal = 6.2831853;
	if (angle.x > maxVal)
	{
		angle.x -= maxVal;
	}
	if (angle.x < 0)
	{
		angle.x += maxVal;
	}
	return angle;
}

float WrapAngle1(float angle, bool halving = false) {
	float maxVal = 6.2831853;
	if (halving)
		maxVal /= 2;
	if (angle > maxVal) {
		angle -= maxVal;
	}
	if (angle < 0) {
		angle += maxVal;
	}
	return angle;
}

float AngleBetweenAngles(float angle1, float angle2) {
	float d = 0;

	d = (angle2 - angle1) % 6.2831853;

	if (d>3.14159265)
		d -= 6.2831853;
	else if (d<-3.14159265)
		d += 6.2831853;
	return d;
}

//Make the 1st number be the same as xChunks, and the 2nd as yChunk vv
[numthreads(1000,1,1)] 
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint starID = id.x;
	float3 polarCoords = CartesianToPolar(float3(starList[starID].x, starList[starID].y, starList[starID].z), playerPos);
	/*/
	float phi_1 = (playerAngle2 - 3.14159265 / 2);
	float phi = -polarCoords.y;
	float lambda_0 = playerAngle1 -3.14159265;
	float lambda = -polarCoords.x;
	float lambdaMinLambda_0 = WrapAngle1(lambda - lambda_0);

	float cos_c = sin(phi_1) * sin(phi) + cos(phi_1)*cos(phi) * cos(lambdaMinLambda_0);
	float x = (cos(phi) * sin(lambdaMinLambda_0)) / cos_c;
	float y = (cos(phi_1) * sin(phi) - sin(phi_1) * cos(phi) * cos(lambdaMinLambda_0)) / cos_c;

	x *= (3.14159265 / fovh);
	y *= (3.14159265 / fovv);

	x += 0.5;
	y += 0.5 * (fovv / fovh);

	
	float xAngle = AngleBetweenAngles(polarCoords.x, playerAngle1);

	float yAngle = AngleBetweenAngles(polarCoords.y, playerAngle2);
	bool a = abs(xAngle) < 3.14159265 / 2;
	bool b = abs(yAngle) < 3.14159265 / 2;
	bool visible = true;// a && b;
	
	float2 pos2 = float2(x * textureWidth, y * textureHeight);*/
	
	float2 pos;
	polarCoords -= float3(playerAngle1 - fovh / 2, playerAngle2 - fovv / 2, 0);
	polarCoords.xy = WrapAngle(polarCoords.xy);
	pos.x = (textureWidth / fovh) * (polarCoords.x);
	pos.y = (textureHeight / fovv) * (polarCoords.y);
	pos.x -= (textureWidth / 2);
	pos.y -= (textureHeight / 2);
	float2 pos2 = pos;
	pos2.x = pos.x * cos(twistyAngle) - pos.y * sin(twistyAngle);
	pos2.y = pos.y * cos(twistyAngle) + pos.x * sin(twistyAngle);
	pos2.x += textureWidth / 2;
	pos2.y += textureHeight / 2;
	
	///Simulate perspective
	float2 toCenter = float2(textureWidth / 2, textureHeight / 2) - pos2;
	float distanceToCenter = sqrt(pow(toCenter.x, 2) + pow(toCenter.y, 2));
	float displacementRatio = distanceToCenter / (textureHeight / 2);
	pos2 -= toCenter * displacementRatio * 0.15 / 1.5707 * fovh; //half pi, aka 90 degrees
	
	
	float2 pos3 = pos2;
	//int2 pos3 = int2((int)pos2.x, (int)pos2.y);
	float apparentMag = 5 * log10(polarCoords.z / 10) + starList[starID].m;
	float4 luminosity = /*255 * */pow(2, ((-apparentMag) - 2 + magIncrease));

	if (pos3.x >= 0 && pos3.x < textureWidth && pos3.y >= 0 && pos3.y < textureHeight){// && visible) {
		Result[pos3] = normalize(float4(starList[starID].r, starList[starID].g, starList[starID].b, 1)) * luminosity;
	}
}


//Make the 1st number be the same as xChunks, and the 2nd as yChunk vv
[numthreads(8, 8, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = float4(0, 0, 0, 0);
}

/*

rgb,   mag
510 = -3
255 = -2
128 = -1
64 = 0
32 = 1
16 = 2
8 = 3
4 = 4
2 = 5
1 = 6*/
