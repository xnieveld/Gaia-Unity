// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSClear

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
uint textureHeight;
uint textureWidth;
uint starCount;
uint starsPerChunk;
float magIncrease;
float3 playerPos;
float playerAngle1;
float playerAngle2;
float twistyAngle;
float fovh;
float fovv;

//Star struct, MUST be identical to star object.
struct Star {
	float x; 
    float y;
    float z;
    float r; //red
    float g; //green
    float b; //blue
    float m; //Magnitude
};


StructuredBuffer<Star> starList; //Buffer of stars
RWTexture2D<float4> Result; //Texture


//Convert cartesian coordinates to polar coordinates
float3 CartesianToPolar(float3 coord, float3 origin) {
	float3 correctedCoord = coord - origin;
	float3 returnCoord = float3(0, 0, 0);
	returnCoord.z = length(correctedCoord);

	returnCoord.x = atan(correctedCoord.z / correctedCoord.x);
	
	if (correctedCoord.x >= 0) {
		returnCoord.x += 3.14159265;
	}
	if (isnan(returnCoord.x))
	{
		if (correctedCoord.x >= 0)
		{
			returnCoord.x = 0;
		}
		else
		{
			returnCoord.x = 3.14159265;
		}
	}
	returnCoord.y = acos(correctedCoord.y / returnCoord.z);

	return returnCoord;
}

//Wrap an agnle such that 361 degrees becomes 1. Except in radians. Angle 2 is between 0 and 180 degrees
float2 WrapAngle(float2 angle)
{
	float maxVal = 3.14159265;

	if (angle.y > maxVal) {
		angle.y -= maxVal;
	}
	if (angle.y < 0) {
		angle.y += maxVal;
	}
	maxVal = 6.2831853;
	if (angle.x > maxVal)
	{
		angle.x -= maxVal;
	}
	if (angle.x < 0)
	{
		angle.x += maxVal;
	}
	return angle;
}

//Wrap a single angle such that 361 becomes 1, wrap at 180 if halving.
float WrapAngle1(float angle, bool halving = false) {
	float maxVal = 6.2831853;
	if (halving)
		maxVal /= 2;
	if (angle > maxVal) {
		angle -= maxVal;
	}
	if (angle < 0) {
		angle += maxVal;
	}
	return angle;
}

//Get the angle between 2 angles
float AngleBetweenAngles(float angle1, float angle2) {
	float d = 0;

	d = (angle2 - angle1) % 6.2831853;

	if (d>3.14159265)
		d -= 6.2831853;
	else if (d<-3.14159265)
		d += 6.2831853;
	return d;
}

//Make the 1st number be the same as xChunks, and the 2nd as yChunk vv
[numthreads(1000,1,1)] 
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint starID = id.x;
	float3 polarCoords = CartesianToPolar(float3(starList[starID].x, starList[starID].y, starList[starID].z), playerPos); //Get the polar coords.

	///This whole bit is important, but not functional now.
	/*/
	float phi_1 = (playerAngle2 - 3.14159265 / 2);
	float phi = -polarCoords.y;
	float lambda_0 = playerAngle1 -3.14159265;
	float lambda = -polarCoords.x;
	float lambdaMinLambda_0 = WrapAngle1(lambda - lambda_0);

	float cos_c = sin(phi_1) * sin(phi) + cos(phi_1)*cos(phi) * cos(lambdaMinLambda_0);
	float x = (cos(phi) * sin(lambdaMinLambda_0)) / cos_c;
	float y = (cos(phi_1) * sin(phi) - sin(phi_1) * cos(phi) * cos(lambdaMinLambda_0)) / cos_c;

	x *= (3.14159265 / fovh);
	y *= (3.14159265 / fovv);

	x += 0.5;
	y += 0.5 * (fovv / fovh);

	//This projection will draw stars of both hemispheres (in front of and behind the player) onto the same plane, so filter 
	//such that only stars with an angle to the player's view direction smaller than 90 degrees will be drawn.
	 
	float xAngle = AngleBetweenAngles(polarCoords.x, playerAngle1);
	float yAngle = AngleBetweenAngles(polarCoords.y, playerAngle2);
	bool a = abs(xAngle) < 3.14159265 / 2;
	bool b = abs(yAngle) < 3.14159265 / 2;
	bool visible = true;// a && b;
	
	float2 pos2 = float2(x * textureWidth, y * textureHeight);*/
	
	float2 pos;
	polarCoords -= float3(playerAngle1 - fovh / 2, playerAngle2 - fovv / 2, 0); //Subtract the player look direction.
	polarCoords.xy = WrapAngle(polarCoords.xy); //Wrap coords, this will make stars on the other side of the 
	pos.x = (textureWidth / fovh) * (polarCoords.x);
	pos.y = (textureHeight / fovv) * (polarCoords.y);
	pos.x -= (textureWidth / 2);
	pos.y -= (textureHeight / 2); //This will essentially draw part of an equirectangular map. It is not perspective. The edges will be very strange.
	float2 pos2 = pos;
	pos2.x = pos.x * cos(twistyAngle) - pos.y * sin(twistyAngle);
	pos2.y = pos.y * cos(twistyAngle) + pos.x * sin(twistyAngle);
	pos2.x += textureWidth / 2;
	pos2.y += textureHeight / 2;
	
	///Simulate perspective
	float2 toCenter = float2(textureWidth / 2, textureHeight / 2) - pos2; //Find pixel vector to center.
	float distanceToCenter = sqrt(pow(toCenter.x, 2) + pow(toCenter.y, 2)); //Find pixel distance to center
	float displacementRatio = distanceToCenter / (textureHeight / 2); //Calculate a ratio compared to the edge
	pos2 -= toCenter * displacementRatio * 0.15 / 1.5707 * fovh; //half pi, aka 90 degrees //Displace the star the further it is from the center to simulate perspective.
	
	
	float2 pos3 = pos2;
	float apparentMag = 5 * log10(polarCoords.z / 10) + starList[starID].m; //Calculate apparent magnitude based on player position and absolute magnitude.
	float4 luminosity = 255 * pow(2, ((-apparentMag) - 2 + magIncrease)); //Calculate luminosity based on apparent magnitude. 5 magnitude lower = 100x as bright. Take pixel logarythic screen luminosity into account. 

	if (pos3.x >= 0 && pos3.x < textureWidth && pos3.y >= 0 && pos3.y < textureHeight){// && visible) { //Only draw stars that are on screen.
		Result[pos3] += normalize(float4(starList[starID].r, starList[starID].g, starList[starID].b, 1)) * luminosity;
	}
}


//Make black.
[numthreads(8, 8, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = float4(0, 0, 0, 0);
}

/* ideal conversion list for apparent magnitude to RGB brightness.
rgb,   mag
510 = -3
255 = -2
128 = -1
64 = 0
32 = 1
16 = 2
8 = 3
4 = 4
2 = 5
1 = 6*/
